class HardestGameEver {

    field Avatar avatar;
    field int avatarSpeed;
    field int avatarSize;
    field Labirinth labirinth;
    field Direction direction;
    field Cell currentBlock;

    constructor HardestGameEver new() {
        
        let avatarSpeed = 2;
        let avatarSize = 5;
        let direction = 0;
        let labirinth = Labirinth.new();
        let avatar = Avatar.new(0,0, avatarSpeed, avatarSize);

        return this;

    }

    method void run() {
        
        var boolean doesUserWantToExit;
        let doesUserWantToExit = false;

        do initialize();

        while (~doesUserWantToExit) {
            do play();

            let doesUserWantToExit = checkIfUserWantsToExit();
        }

        do destroy();

        return;
    }

    method void initialize() {
        do avatar.render();
        do labirinth.render();
        
        return;
    }

    method void destroy() {
        do labirinth.destroy();
        do avatar.destroy();
        
        do Memory.deAlloc(this);
        
        return;
    }

    method boolean checkIfUserWantsToExit() {
        var char keyPressed;
        var boolean exit;

        let keyPressed = Keyboard.keyPressed();
        let exit = false;
      
        if (keyPressed = 81)  { let exit = true; } // q key

        return exit;
    }

    method void play() {
        do moveAvatar();
        return;
    }

    method void moveAvatar() {

        do defineMoveDirection();

        if ((direction = 1)) {
            if (~(isWallLeft())) { do avatar.moveLeft(); }
        }
        
        if (direction = 2)  {
            if (~(isWallUp())) { do avatar.moveUp(); }
        }
        
        if (direction = 3)  {
            if (~(isWallRight())) { do avatar.moveRight(); }
        }
        
        if (direction = 4)  {
            if (~(isWallDown())) { do avatar.moveDown(); }
        }
        
        do Sys.wait(5);  // delays the next movement
        
        return;
    }

    method boolean isWallLeft() {
        var boolean isWall;
        var int nextX, nextY, relativeX;
        var Cell currentBlock, nextBlock;
        var boolean isMovingOutOfCurrentBlock;

        let isWall = false;
        
        let currentBlock = getCurrentBlock();

        let nextX = avatar.getX() - avatarSpeed;
        let nextY = avatar.getY();
        let nextBlock = labirinth.getBlockFromXY(nextX, nextY);
        
        let relativeX = nextX - currentBlock.getX();

        let isMovingOutOfCurrentBlock = ((relativeX < 0) | (relativeX = 0));

        if (isMovingOutOfCurrentBlock & (currentBlock.getBorder() = 1)) { let isWall = true; }

        return isWall;
    }

    method boolean isWallUp() {
        var boolean isWall;
        var int nextX, nextY, relativeY;
        var Cell currentBlock, nextBlock;
        var boolean isMovingOutOfCurrentBlock;

        let isWall = false;
        
        let currentBlock = getCurrentBlock();

        let nextX = avatar.getX();
        let nextY = avatar.getY() - avatarSpeed;
        let nextBlock = labirinth.getBlockFromXY(nextX, nextY);
        
        let relativeY = nextY - currentBlock.getY();

        let isMovingOutOfCurrentBlock = ((relativeY < 0) | (relativeY = 0));

        if (isMovingOutOfCurrentBlock & (currentBlock.getBorder() = 2)) { let isWall = true; }

        return isWall;
    }

    method boolean isWallRight() {
        var boolean isWall;
        var int nextX, nextY, relativeX;
        var Cell currentBlock, nextBlock;
        var boolean isMovingOutOfCurrentBlock;

        let isWall = false;
        
        let currentBlock = getCurrentBlock();

        let nextX = avatar.getX() + avatarSpeed + avatarSize + 1;
        let nextY = avatar.getY();

        if (~(nextX > 512)) { // TODO: REMOVE THIS IF
            let nextBlock = labirinth.getBlockFromXY(nextX, nextY);
            
            let relativeX = nextX - (currentBlock.getX() + currentBlock.getWidth());

            let isMovingOutOfCurrentBlock = ((relativeX > 0) | (relativeX = 0));

            if (isMovingOutOfCurrentBlock & (currentBlock.getBorder() = 3)) { let isWall = true; }
        }
        
        return isWall;
    }

    method boolean isWallDown() {
        var boolean isWall;
        var int nextX, nextY, relativeY;
        var Cell currentBlock, nextBlock;
        var boolean isMovingOutOfCurrentBlock;

        let isWall = false;
        
        let currentBlock = getCurrentBlock();

        let nextX = avatar.getX();
        let nextY = avatar.getY() + avatarSpeed + avatarSize + 1;
        let nextBlock = labirinth.getBlockFromXY(nextX, nextY);
        
        let relativeY = nextY - (currentBlock.getY() + currentBlock.getHeight());

        let isMovingOutOfCurrentBlock = ((relativeY > 0) | (relativeY = 0));

        if (isMovingOutOfCurrentBlock & (currentBlock.getBorder() = 4)) { let isWall = true; }

        return isWall;
    }

    method Cell getCurrentBlock() {
        var int currentX, currentY;
        
        let currentX = avatar.getX();
        let currentY = avatar.getY();

        let currentBlock = labirinth.getBlockFromXY(currentX, currentY);

        return currentBlock;
    }

    method void defineMoveDirection() {
        
        var char keyPressed;        
        let keyPressed = Keyboard.keyPressed();

        if (keyPressed = 0)   { let direction = 0; }   // no key is pressed
        if (keyPressed = 130) { let direction = 1; }   // left arrow
        if (keyPressed = 131) { let direction = 2; }   // up arrow
        if (keyPressed = 132) { let direction = 3; }   // right arrow
        if (keyPressed = 133) { let direction = 4; }   // down arrow

        return;
    }

}