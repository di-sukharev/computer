// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {

    static Array memory;
    static Array freeList;

    static int SIZE;
    static int NEXT; 

    static int heapBase, heapEnd;

    /** Initializes the class. */
    function void init() {

        let heapBase = 2048;
        let heapEnd = 16384; // MAY BE 16383

        let memory = 0;
        let freeList = heapBase;

        let SIZE = 0;
        let NEXT = 1;

        let freeList[NEXT] = null;
        let freeList[SIZE] = heapEnd - heapBase;

        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return memory[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let memory[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var Array block;

        if ((size < 1) | (size > (heapEnd - heapBase))) { return null; }

        let block = Memory.getFreeMemoryBlockFromList(size);

        return block;
    }

    /** Slices (size + 2) registers from block found in FreeList. */
    function int getFreeMemoryBlockFromList(int size) {
        var int registersUsedForMetaData, actualSizeOfTheBlock;
        var Array block, segment;

        let registersUsedForMetaData = 1;
        let actualSizeOfTheBlock = size + registersUsedForMetaData;

        let segment = Memory.findPossibleSegmentInList(actualSizeOfTheBlock);
        let block = Memory.sliceBlockFromSegment(segment, actualSizeOfTheBlock);

        let block[SIZE] = size; // saving metadata
        let block = block + registersUsedForMetaData; // setting pointer after metadata register

        return block;
    }
    
    // /** Implementing first search strategy. */
    function Array findPossibleSegmentInList(int size) {
        var Array currentSegment;

        // find possible segment, starting with freeList
        let currentSegment = freeList;
        while (currentSegment[SIZE] < size) { let currentSegment = currentSegment[NEXT]; }

        return currentSegment;
    }

    // /** Slicing block of size from the bottom of a given segment */
    function int sliceBlockFromSegment(Array segment, int size) {
        var int baseAddress;
        var int reducedSize;

        let reducedSize = segment[SIZE] - size;

        // slice n registers from the bottom of a given register, where n = size
        // adding "+2" because we have 2 meta-registers in each segment for NEXT and SIZE constants
        let baseAddress = (segment + 2) + reducedSize;

        // reduce segment size by the sliced block size
        let segment[SIZE] = reducedSize;

        return baseAddress;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array object) {
        var int lastSegment;

        // Step 1 register back, point to the object base, where [SIZE] is stored.
        // So, now object[SIZE] is pointing to object[0] where size was stored during allocation.
        let object = object - 1;
        // reduce object[SIZE] by 1, because we will use this register for setting NEXT header
        let object[SIZE] = object[SIZE] - 1;
        let object[NEXT] = null; // set NEXT header

        // find list segment
        let lastSegment = freeList;
        while (~(lastSegment[NEXT] = null)) { let lastSegment = lastSegment[NEXT]; }

        // set NEXT header of the last segment to object
        let lastSegment[NEXT] = object;

        return;
    }    
}
