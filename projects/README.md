<!-- Если читаете файл в VSCode — нажмите ctrl+shift+v, чтобы включить режим просмотра. Для macOS — cmd+shift+v. -->

# HDL (язык описания железа компьютера)

HDL (hardware description language) — это язык на котором проектируют аппаратное обеспечение (железо) компьютера. HDL код запускают в симуляторе железа. Симулятор железа — это программа, которая симулирует компьютерную систему.

В XXI веке чипы не паяют руками, их производят на заводах. Вы пишите HDL код — робот-паяльник на заводе паяет чип. Проектировать чип в симуляторе железа проще, чем паять его руками. Цена ошибки меньше, процесс разработки быстрее.

Два основных HDL языка — System Verilog и VHDL. Именно их используют в продакшене, но мы не будем их рассматривать, потому что они слишком большие. Мы будем использовать собственную упрощенную версию HDL, похожую на System Verilog.

## Синтаксис языка

Любой язык программирования состоит из токенов, HDL не исключение. Токены — это ключевые слова и знаки, которые используются в языке. По-простому, токены в языке — это как слова и знаки препинания в тексте.

Токены не могут стоять в любой последовательности, также как слова в тексте. Компьютер понимает только строго определенный порядок токенов. Этот порядок называется синтаксис.

Например, в языке HDL используются четыре ключевых слова: `CHIP`, `IN`, `OUT`, `PARTS`. И двенадцать знаков: `{ . ( : / [ } ] * = ) ,`. Всего шестнадцать токенов. Не так много, весь язык можно выучить за полчаса.

Ключевые слова и знаки образуют синтаксическую конструкцию описания электросхемы. Эта конструкция используется во всех схемах, ее HDL код ниже:

```java
CHIP chip_name { // название схемы
    IN a, b, c; // инпуты, которые принимает схема
    OUT x, y, z; // аутпуты, которые возвращает схема

    PARTS:
        // … реализация логической схемы (скрыта) …
}
```

Слешами `//` выделены комментарии, они не являются частью схемы.

Ключевое слово `CHIP` означает начало реализации чипа. За ключевым словом идет название чипа. В данном случае чип называется `chip_name`, это пример названия. Ключевое слово `CHIP` не означает, что электросхема обязательно чип, оно означает начало реализации электросхемы. Авторы языка решили не вводить ключевое слово `GATE`, чтобы не усложнять язык. И гейты и чипы в нашем HDL начинаются со слова `CHIP`.

Ключевое слово `IN` означает список инпутов, которые принимает схема. Ключевое слово `OUT` означает список аутпутов, которые схема возвращает.

Знаки `, { ; : }` являются разделителями. Например фигурные скобки обозначают `{ начало и конец }` реализации схемы. Через запятую перечисляются инпуты `IN: a, b, c` и аутпуты `OUT: x, y, z`. Точка с запятой означает конец объявления инпутов и аутпутов.

Инпуты и аутпуты — это интерфейс схемы. Ключевое слово `PARTS` означает начало реализации схемы.

Давайте рассмотрим описания разных гейтов на HDL. Начнем с гейта NOT:

```java
CHIP Not { // называется Not
    IN in; // принимает один инпут: in;
    OUT out; // возвращает один аутпут: out;

    PARTS:
        // … реализация логической схемы NOT (пока скрыта) …
}
```

Рассмотрим еще один пример:

```java
CHIP And {
    IN a, b;
    OUT out;

    PARTS:
        // … реализация логической схемы (пока скрыта) …

}
```

Как называется гейт? Сколько инпутов принимает? Сколько возвращает аутпутов?

Ответы (не читайте сразу, подумайте): Чип называется `And`, принимает два инпута `a`, `b` и возвращает один аутпут `out`.

Теперь, когда мы разобрались, что означают ключевые слова и знаки, давайте перейдем к реализации логических схем.

## Реализация логических схем на HDL

Для примера рассмотрим реализацию составного гейта NAND из гейтов AND и NOT.

```java
CHIP Nand {

    IN x, y; // получаем два инпута: x, y;
    OUT z; // должны вернуть один аутпут: z;

    PARTS:
    // в гейт And передаем оба входящих инпута: a<-x, b<-y;
    // out записываем в xANDy шину: out->xANDy;
    And(a=x, b=y, out=xANDy);
    // далее передаем шину xANDy в инпут гейта Not: in<-xANDy;
    // полученный out выводим в главный out: out->z;
    Not(in=xANDy, out=z);

}
```

Гейт NAND получает два инпута: `x` и `y`. Передаем их в гейт And, результат And операции записываем в шину `xANDy`: `And(a=x, b=y, out=xANDy);`. Здесь шина `xANDy` играет роль переменной, ее можно назвать как удобно, я назвал `xANDy`. Далее передаем шину `xANDy` в гейт Not и записываем результат операции Not в `z`. Аутпут `z` считается основным, симулятор автоматически подхватит его, когда вы создадите шину с названием `z`.

Теперь посмотрим на составной гейт Nand еще раз без комментариев.

```java
CHIP Nand {
    IN x, y;
    OUT z;

    PARTS:
        And(a=x, b=y, out=xANDy);
        Not(in=xANDy, out=z);
}
```

Вы можете думать о знаках равно (=), как о соединяющихся проводах. В гейт Nand входит два провода-инпута (`x` и `y`) и выходит один провод-аутпут `z`. Провода-инпуты гейта Nand соединяются с проводами-инпутами гейта And (`a=x` и `b=y`), а провод-аутпут гейта And соединяется с проводом-инпутом гейта Not (`in=xANDy`). В итоге, провод-аутпут `out` гейта Not соединяется с главным аутпутом `z`, вот так: `out=z`.

> Про провода: в производстве чипов используется процесс называемый [фотолитография](https://ru.wikipedia.org/wiki/Фотолитография), позволяющий проектировать чипы в нано-масштабе. Поэтому в чипах не используются провода, скорее микроскопические нано-нити проводящие ток. Я буду называть их провода.

Аутпуты (провода), которые выходят из гейтов внутри реализации, называются пинами. Еще их называют шинами. В примере выше пином является `xANDy`, в него записывается аутпут гейта And (`out=xANDy`). Пины играют роль переменных. Их можно называть как угодно, но названия не должны содержать знак нижнего подчеркивания `_`. В названиях главное, чтобы они были понятны вам.

## Как проверить правильно ли вы собрали гейт

Убедитесь, что [установили расширения](https://github.com/di-sukharev/computer/tree/master/README.md) для VSCode (редактора кода).

Чтобы проверить, правильно ли вы разработали гейт:

1. Откройте в VSCode `.hdl` файл гейта.
2. Сохраните код `ctrl + s` или `cmd + s` на macOS.
3. Нажмите сочетание клавиш `ctrl + shift + p` или `cmd + shift + p` (macOS) и выберите опцию `Nand2Tetris: Run Code`.

Эта операция запустит `.hdl` файл в симуляторе. Симулятор проверит, соответствует ли `.cmp` файл гейта `.out` файлу. Файлы `.cmp` и `.out` лежат в одной папке с `.hdl` файлом.

Если файлы соответствуют — вы увидите текст `Comparison Successfully with code=0` в терминале. Поздравляю, вы успешно собрали гейт 🎉

Если вы увидели текст `Comparison Failure with code=255` — гейт реализован неправильно. Подумайте еще.

Чтобы посмотреть результаты работы вашего гейта — можно открыть файл `.out` — это таблица истинности вашего гейта. Она будет меняться, в зависимости от того, как работает ваш гейт. Файл `.cmp` описывает таблицу истинности к которой нужно прийти, она никогда не меняется.

Ниже пример запуска файла `And.hdl` в симуляторе:

![Инструкция — как запустить код через расширение (кликните на ссылку с зажатым ctrl или cmd для macOS)](/img/how2run-code.png)

## Далее

Теперь, когда (я очень надеюсь) вы поняли, как писать HDL код — [переходите к проектированию составных гейтов](https://github.com/di-sukharev/computer/tree/master/projects/01-gates/compound/README.md).

Даже если не поняли, все равно переходите к практике, вы обязательно разберетесь в процессе.

## Учебник

[Читайте мой учебник компьютерных наук](https://www.sukharev.io/textbook). В нем дается теория помогающая выполнять практические задания.

## Вопросы

Задавайте вопросы в телеграм группе [t.me/sukharev_qa](https://www.t.me/sukharev_qa)
