<!-- Если читаете файл в VSCode — нажмите ctrl+shift+v, чтобы включить режим просмотра. Для macOS — cmd+shift+v. -->

# Язык ассемблера

Рассмотрим язык ассемблера процессора, который мы собрали в предыдущей главе. Собранный процессор имеет два регистра (А, D) и оперирует 32K регистровой памятью.

Наш язык ассемблера поддерживает два типа инструкций: А и C. Рассмотрим их подробнее.

## Инструкция А (address)

Инструкция А отвечает за адресацию RAM и ROM памяти и сохранение в регистр А 15-битного значения.

Пример инструкции А: `@791` — записать в регистр А число 791.

Еще пример: `@812` — записать в регистр А чисто 812.

Когда вы записываете какое-то число в регистр А, происходит два побочных действия:

1. активируется регистр RAM[A] для записи/чтения, об этом чуть позже.
2. PC `in` инпут становится равен значению в регистре А.

## Инструкция С (compute)

Инструкция C отвечает за выполнение арифметико-логических операций в АЛУ и сохранение результата в один из регистров: A, D, M. A и D — это локальные регистры; регистр M – это RAM регистр.

Адресация регистра M происходит через регистр А. То есть, если хотите прочитать значение из RAM[17] — нужно записать число 17 в регистр А и обратиться к регистру M, вот так:

```c
// записываем RAM[17] в регистр D
@17
D=M
```

Если хотите записать значение в RAM[99] — нужно записать 99 в регистр А и аналогично чтению обратиться к регистру M, вот так:

```c
// сохраняем 10 в регистр RAM[99]
@10 // A = 10
D=A // D=10
@99
M=D // RAM[99]=D
```

## Переменные

Переменные хранят данные.

Пример использования переменной:

```c
// сохраним число 100 в переменную variable
@100 // A=100
D=A // D=100
@variable // A=variable
M=D // M=RAM[variable]=D=100
```

В примере выше мы сохранили значение 100 в переменную. Мы также могли сохранить значение в любой из RAM регистров, просто по адресу, но запоминать адреса регистров сложно, поэтому используются переменные. Запомнить, что в переменной `sum` лежит сумма двух чисел проще, чем вспоминать адрес регистра в который вы эту сумму сохранили, особенно, когда таких регистров много.

### Предустановленные переменные

В нашем языке ассемблера есть двадцать три предустановленных переменных, их можно использовать без объявления. Вот они:

1. R0 — по умолчанию установлена в значение 0
2. R1 — по умолчанию установлена в 1
3. R2 — установлена в 2
4. R3 — установлена в 3
5. …
6. R15 — установлена в 15
7. SP — установлена в 0 (подробнее обсуждается в следующих главах)
8. LCL — установлена в 1 (подробнее обсуждается в следующих главах)
9. ARG — установлена в 2 (подробнее в следующих главах)
10. THIS — установлена в 3 (подробнее в следующих главах)
11. THAT — установлена в 4 (подробнее в следующих главах)
12. SCREEN — установлена в 16384 (это начало I/O регистров экрана)
13. KBD — установлена в 24576 (это I/O регистр клавиатуры)

Обратите внимание на переменные SCREEN и KBD, они нужны для взаимодействия с устройствами ввода/вывода — экраном и клавиатурой. Переменная SCREEN хранит адрес первого I/O регистра экрана. Регистры экрана начинаются с 16384 регистра и заканчиваются на 24575 регистре включительно. Переменная KBD хранит адрес регистр клавиатуры. Об этом позже.

## Переходы

Еще инструкция С отвечает за выполнение переходов. Если хотите перейти к 15-ой инструкции (или любой другой) — записываете 15-ть в регистр А и через инструкцию С выполняете переход, вот так:

```c
@15 // A=15
0;JMP // безусловный переход к 15-ой инструкции
```

В программе выше мы переходим к 15-ой инструкции, но инструкции всего две, поэтому такой пример не имеет смысла, давайте рассмотрим полноценную программу.

```c
// Программа: Signum.asm
// Вычисляет: if R0>0
//              R1=1
//            else
//              R1=0
// Использование: запишите значение в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M    // D = RAM[0]
@8
D;JGT  // if R0>0 goto POSITIVE
@R1
M=0    // else RAM[1]=0
@10
0;JMP  // goto end
@R1
M=1    // R1=1
@10
0;JMP
```

В примере программы выше условный переход происходит на четвертой строке `D;JGT`, а указатель на инструкцию, к которой осуществляется переход, указан на третьей строке `@8`. Если значение в регистре R0 больше нуля происходит переход к 8-ой инструкции.

Еще переходы осуществляются на 7-ой и 11-ой инструкциях. Там происходит переход к 10-ой инструкции.

![инструкция С](img/C-instruction.png)

## Лейблы

Лейблы позволяют удобнее осуществлять переходы. Без лейблов переход осуществляется по номеру строки на которой расположена нужная инструкция. С лейблами переход осуществляется по лейблу. Звучит непонятно, рассмотрим пример программы из последнего примера выше, но с лейблами.

```c
// Программа: Signum.asm
// Вычисляет: if R0>0
//              R1=1
//            else
//              R1=0
// Использование: запишите значение в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M    // D = RAM[0]
@POSITIVE
D;JGT  // if R0>0 goto POSITIVE
@R1
M=0    // else RAM[1]=0
@END
0;JMP  // goto end
(POSITIVE) // лейбл POSITIVE
@R1
M=1    // R1=1
(END) // лейбл END: бесконечный цикл
@END
0;JMP
```

Видите, мы убрали переходы по номеру строки и стали переходить к лейблам. Это удобнее, так исчезает привязка программы к номерам строк.

## Системы ввода/вывода

Системы ввода/вывода (input/output — I/O) используются для подключению к компьютеру периферийных устройств: клавиатуры, мыши, принтера, экрана и других.

Один из методов связи с периферийными устройствами называется «вводом/выводом, отображенным в память» (memory-mapped I/O, MMIO).

В MMIO процессор получает доступ к периферийным устройствам через оперативную память. Мышь, клавиатура и другие устройства занимают часть адресного пространства в RAM. В нашем компьютере адреса с 16384 регистра по 24575 регистр выделены под экран, а 24576 регистр выделен под клавиатуру. Запись и чтение из I/O регистров происходит точно так же, как с обыкновенными регистрами.

Подробнее рассмотрим отображенные в память клавиатуру и экран.

### Клавиатура

Когда нажимаете клавишу на клавиатуре, в 24576 регистр записывается скан-код (scan-code) клавиши. Хотите узнать, какую клавишу нажал пользователь — читаете значение из регистра 24576, вот так:

```c
@KBD // A=24576
D=M // D=scan_code
```

Вот таблица всех скан-кодов клавиатуры:

![скан-коды](img/scan-codes.png)

### Экран

Хотите нарисовать что-то на экране — записываете единицы в нужные биты I/O регистров экрана. Для этого существует алгоритм:

1. Выбираем пиксель, который хотим «закрасить»: нужны его `x/y` координаты.
2. Ищем 16-битный регистр, который отвечает за отображение выбранного пикселя: `register = y * (512/16) + x / (256/16)`.
3. Ищем нужный бит в 16-битном регистре, который отвечает за цвет пикселя: `x%16`, где `%` операция нахождения остатка от деления. Бит = пиксель. Регистр = 16 бит = 16 пикселей.

У нас черно-белый экран 512x256 пикселей. Допустим, мы хотим закрасить 77x112 пиксель в черный цвет. Найдем нужный бит в памяти по алгоритму выше:

1. Координаты пикселя уже выбрали: x=77, y=112.
2. Ищем регистр в RAM: `112 * 32 + 77 / 16 = 3588`. Нам нужен `RAM[3588]` регистр, но он 16-битный, а значит отвечает за отображение 16-ти пикселей на экране, а нам нужен один 77x112 пиксель.
3. Найдем этот один пиксель: `77%16=13`. Нам нужен 13-ый бит в `RAM[3588]` регистре, он отвечает за 77x112 пиксель. Чтобы закрасить выбранный пиксель в черный — нужно записать в 13-ый бит единицу. Чтобы закрасить этот пиксель в белый — нужно записать в 13-ый бит ноль. Белый = 0; черный = 1.

## Примеры кода

```c
// D=10
@10
D=A

// D++
D=D+1

// D=RAM[17]
@17
D=M

// RAM[17]=D
@17
M=D

// RAM[17]=10
@10
D=A
@17
M=D

// RAM[5] = RAM[3]
@3
D=M
@5
M=D
```

## Примеры программ

```c
// Программа: Flip.asm
// меняет местами значения в регистрах
// RAM[0] и RAM[1]
@R1
D=M
@temp
M=D // temp = R1
@R0
D=M
@R1
M=D // R1 = R0
@temp
D=M
@R0
M=D // R0 = temp
(END) // лейбл END: бесконечный цикл
@END
0;JMP
```

```c
// Программа: Add2.asm
// Вычисляет: RAM[2] = RAM[0] + RAM[1]
// Использование: запишите значения в RAM[0] и RAM[1],
//                смотрите результат в RAM[2]
@0
D=M   // D = RAM[0]
@1
D=D+M // D = D + RAM[1]
@2
M=D   // RAM[2] = D
```

```c
// Программа: Signum.asm
// Вычисляет: if R0>0
//              R1=1
//            else
//              R1=0
// Использование: запишите значение в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M    // D = RAM[0]
@POSITIVE
D;JGT  // if R0>0 goto POSITIVE
@R1
M=0    // else RAM[1]=0
@END
0;JMP  // goto end
(POSITIVE)
@R1
M=1    // R1=1
(END) // лейбл END: бесконечный цикл
@END
0;JMP
```

```c
// Программа: Sum1toN.asm
// Вычисляет: RAM[1] = 1+2+ ... +n
// Использование: запишите значение (n) в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M
@n
M=D   // n = R0
@i
M=1   // i = 1
@sum
M=0   // sum = 0
(LOOP)
@i
D=M
@n
D=D-M
@STOP
D;JGT  // if i > n goto STOP
@sum
D=M
@i
D=D+M
@sum
M=D    // sum = sum + i
@i
M=M+1  // i = i + 1
@LOOP
0;JMP
(STOP)
@sum
D=M
@R1
M=D    // RAM[1] = sum
(END)
@END
0;JMP
```

```c
// Программа: Rectangle.asm
// Рисует черный прямоугольник
// в верхнем левом углу экрана
// ширина 16 пикселей, высота
// RAM[0] пикселей.
// Использование: запишите значение
// (высоту прямоугольника) в RAM[0].
@SCREEN
D=A
@addr
M=D // addr = 16384
    // (base-адрес экрана)
@0
D=M
@n
M=D // n = RAM[0]
@i
M=0 // i = 0

(LOOP)
@i
D=M
@n
D=D-M
@END
D;JGT // if i>n goto END
@addr
A=M
M=-1 // RAM[addr]=1111111111111111
@i
M=M+1 // i=i+1
@32
D=A
@addr
M=D+M // addr = addr + 32
@LOOP
0;JMP // goto LOOP

(END)
@END // конец программы
0;JMP // бесконечный цикл
```

## Задача

Напишите две программы: Mult.asm и Fill.asm в соответствующих папках mult и fill.

Чтобы запустить программу, откройте ее в симуляторе процессора. Симулятор процессора запускается через меню команд — ctrl+shift+p, cmd+shift+p для macOS: `Nand2Tetris: Open CPU Simulator`.

![как запустить программу](img/how2runProgramm.png)

После установки значений в память не забудьте переключить опцию `Animation` на `no animation`, так программа выполняется быстрее.
