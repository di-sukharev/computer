<!-- Если читаете файл в VSCode — нажмите ctrl+shift+v, чтобы включить режим просмотра. Для macOS — cmd+shift+v. -->

# Язык ассемблера

Рассмотрим язык ассемблера процессора, который мы собрали в предыдущей главе. Собранный процессор имеет два регистра (А, D) и оперирует 32K регистровой памятью.

Наш язык ассемблера поддерживает два типа инструкций: А и C. Рассмотрим их подробнее.

## Инструкция А (address)

Инструкция А отвечает за адресацию RAM и ROM памяти и сохранение в регистр А 15-битного значения.

Пример инструкции А: `@791` — записать в регистр А число 791.

Еще пример: `@812` — записать в регистр А чисто 812.

Когда вы записываете какое-то число в регистр А, происходит два побочных действия:

1. активируется регистр RAM[A] для записи/чтения, об этом чуть позже
2. PC `in` инпут становится равен значению в регистре А.

## Инструкция С (compute)

Инструкция C отвечает за выполнение арифметико-логических операций в АЛУ и сохранение результата в один из регистров: A, D, M. A и D — это локальные регистры; регистр M – это RAM регистр.

Адресация регистра M происходит через регистр А. То есть, если хотите прочитать значение из RAM[17] — нужно записать число 17 в регистр А и просто обратиться к регистру M, вот так:

```c
// D=RAM[17]
@17
D=M
```

Если хотите записать значение в RAM[99] — нужно записать 99 в регистр А и аналогично чтению обратиться к регистру M, вот так:

```c
// RAM[99]=10
@10
D=A
@99
M=D
```

Еще инструкция С отвечает за выполнение переходов. Если хотите перейти к 15-ой инструкции (или любой другой) — записываете 15-ть в регистр А и через инструкцию С выполняете переход, вот так:

```c
@15
0;JMP
```

В программе выше всего две инструкции, поэтому такой пример не имеет смысла, давайте рассмотрим полноценную программу.

```c
// Программа: Signum.asm
// Вычисляет: if R0>0
//              R1=1
//            else
//              R1=0
// Использование: запишите значение в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M    // D = RAM[0]
@8
D;JGT  // if R0>0 goto POSITIVE
@R1
M=0    // else RAM[1]=0
@10
0;JMP  // goto end
@R1
M=1    // R1=1
@10
0;JMP
```

В примере программы выше условный переход происходит на четвертой строке `D;JGT`, а указатель на инструкцию, к которой осуществляется переход, указан на третьей строке `@8`. Если значение в регистре R0 больше нуля происходит переход к 8-ой инструкции.

Еще переход осуществляется на 7-ой и 11-ой инструкциях. Там происходит переход к 10-ой инструкции.

![инструкция С](img/C-instruction.png)

## Лейблы

Лейблы позволяют удобнее осуществлять переходы. Без лейблов переход осуществляется по номеру строки на которой расположена нужная инструкция. С лейблами переход осуществляется по лейблу. Звучит непонятно, рассмотрим пример программы из последнего примера выше, но с лейблами.

```c
// Программа: Signum.asm
// Вычисляет: if R0>0
//              R1=1
//            else
//              R1=0
// Использование: запишите значение в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M    // D = RAM[0]
@POSITIVE
D;JGT  // if R0>0 goto POSITIVE
@R1
M=0    // else RAM[1]=0
@END
0;JMP  // goto end
(POSITIVE) // лейбл POSITIVE
@R1
M=1    // R1=1
(END) // лейбл END: бесконечный цикл
@END
0;JMP
```

Видите, мы убрали переходы по номеру строки и стали переходить к лейблам. Это удобнее, так исчезает привязка программы к номерам строк.

## Переменные

Переменные хранят данные.

Пример использования переменной:

```c
// variable=100
@100
D=A
@variable
M=D
```

В примере выше мы сохранили значение 100 в переменную. Мы также могли сохранить значение в любой из RAM регистров, просто по адресу, но запоминать адреса регистров сложно, поэтому используются переменные. Запомнить, что в переменной `sum` лежит сумма двух чисел проще, чем вспоминать адрес регистра в который вы эту сумму сохранили, особенно, когда таких регистров много.

### Предустановленные переменные

В нашем языке ассемблера есть двадцать три предустановленных переменных, их можно использовать без объявления. Вот они:

1. R0 — по умолчанию установлена в 0
2. R1 — по умолчанию установлена в 1
3. R2 — установлена в 2
4. R3 — установлена в 3
5. …
6. R15 — установлена в 15
7. SP — установлена в 0 (подробнее обсуждается в следующих главах)
8. LCL — установлена в 1 (подробнее обсуждается в следующих главах)
9. ARG — установлена в 2 (подробнее в следующих главах)
10. THIS — установлена в 3 (подробнее в следующих главах)
11. THAT — установлена в 4 (подробнее в следующих главах)
12. SCREEN — установлена в 16384 (это начало I/O регистров экрана)
13. KBD — установлена в 24576 (это I/O регистр клавиатуры)

## Примеры кода

```c
// D=10
@10
D=A

// D++
D=D+1

// D=RAM[17]
@17
D=M

// RAM[17]=D
@17
M=D

// RAM[17]=10
@10
D=A
@17
M=D

// RAM[5] = RAM[3]
@3
D=M
@5
M=D
```

## Примеры программ

```c
// Программа: Flip.asm
// меняет местами значения в регистрах
// RAM[0] и RAM[1]
@R1
D=M
@temp
M=D // temp = R1
@R0
D=M
@R1
M=D // R1 = R0
@temp
D=M
@R0
M=D // R0 = temp
(END) // лейбл END: бесконечный цикл
@END
0;JMP
```

```c
// Программа: Add2.asm
// Вычисляет: RAM[2] = RAM[0] + RAM[1]
// Использование: запишите значения в RAM[0] и RAM[1],
//                смотрите результат в RAM[2]
@0
D=M   // D = RAM[0]
@1
D=D+M // D = D + RAM[1]
@2
M=D   // RAM[2] = D
```

```c
// Программа: Signum.asm
// Вычисляет: if R0>0
//              R1=1
//            else
//              R1=0
// Использование: запишите значение в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M    // D = RAM[0]
@POSITIVE
D;JGT  // if R0>0 goto POSITIVE
@R1
M=0    // else RAM[1]=0
@END
0;JMP  // goto end
(POSITIVE)
@R1
M=1    // R1=1
(END) // лейбл END: бесконечный цикл
@END
0;JMP
```

```c
// Программа: Sum1toN.asm
// Вычисляет: RAM[1] = 1+2+ ... +n
// Использование: запишите значение (n) в RAM[0],
//                смотрите результат в RAM[1]
@R0
D=M
@n
M=D   // n = R0
@i
M=1   // i = 1
@sum
M=0   // sum = 0
(LOOP)
@i
D=M
@n
D=D-M
@STOP
D;JGT  // if i > n goto STOP
@sum
D=M
@i
D=D+M
@sum
M=D    // sum = sum + i
@i
M=M+1  // i = i + 1
@LOOP
0;JMP
(STOP)
@sum
D=M
@R1
M=D    // RAM[1] = sum
(END)
@END
0;JMP
```

```c
// Программа: Rectangle.asm
// Рисует черный прямоугольник
// в верхнем левом углу экрана
// ширина 16 пикселей, высота
// RAM[0] пикселей.
// Использование: запишите значение
// (высоту прямоугольника) в RAM[0].
@SCREEN
D=A
@addr
M=D // addr = 16384
    // (base-адрес экрана)
@0
D=M
@n
M=D // n = RAM[0]
@i
M=0 // i = 0

(LOOP)
@i
D=M
@n
D=D-M
@END
D;JGT // if i>n goto END
@addr
A=M
M=-1 // RAM[addr]=1111111111111111
@i
M=M+1 // i=i+1
@32
D=A
@addr
M=D+M // addr = addr + 32
@LOOP
0;JMP // goto LOOP

(END)
@END // конец программы
0;JMP // бесконечный цикл
```
